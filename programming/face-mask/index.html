<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    

    <link rel="icon" type="gif" href="assets/img/favicon-1.gif">
    
    <style>
        @font-face {
            font-family: 'Penray';
            src: url('Penray-Extrabold.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .text-input {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 20px;
            background-color: #ffffff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 18px;
            z-index: 10;
            width: 300px;
            text-align: center;
            outline: none;
        }
        
        .text-input:focus {
            outline: none;
        }
        
        .hide-video-control {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #ffffff;
        }
        
        .hide-video-control input[type="checkbox"] {
            cursor: pointer;
        }
        
        .text-3d-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            transform-style: preserve-3d;
            perspective: 2000px;
        }
        
        .text-3d-layer {
            position: absolute;
            color: #ffffff;
            font-family: 'Penray', Arial, sans-serif;
            font-weight: normal;
            font-size: 180px;
            white-space: nowrap;
            transform-style: preserve-3d;
            transform-origin: center center;
            opacity: 1;
            backface-visibility: visible;
            -webkit-backface-visibility: visible;
            text-transform: uppercase;
        }
        
        .eye-letter, .mouth-letter {
            position: absolute;
            color: #ffffff;
            font-family: 'Penray', Arial, sans-serif;
            font-weight: normal;
            font-size: 80px;
            transform-style: preserve-3d;
            transform-origin: center center;
            pointer-events: none;
            z-index: 6;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="text3dContainer" class="text-3d-container"></div>
        <div class="hide-video-control">
            <input type="checkbox" id="hideVideoCheckbox">
            <label for="hideVideoCheckbox">Hide video</label>
        </div>
        <input type="text" id="textInput" class="text-input" placeholder="FACE MASK" value="FACE MASK">
    </div>

    <script>
        /*
         * NOTE ON TONGUE DETECTION:
         * MediaPipe Face Mesh does not have dedicated tongue landmarks. However, we've
         * implemented a novel approach using PIXEL COLOR ANALYSIS:
         * 
         * How it works:
         * 1. Detects when mouth is open (shape analysis)
         * 2. Samples pixel colors from center of mouth region
         * 3. Calculates average brightness:
         *    - Very dark pixels (< 50) = mouth cavity visible (shocked face) → O
         *    - Lighter pixels (> 60) = tongue/flesh visible → P
         * 
         * This distinguishes between:
         * - Open mouth showing dark cavity (shocked expression): Shows O
         * - Open mouth with tongue out (lighter flesh tones): Shows P rotated 90°
         * 
         * Try sticking your tongue out with your mouth moderately open!
         */
        
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('textInput');
        const text3dContainer = document.getElementById('text3dContainer');
        const hideVideoCheckbox = document.getElementById('hideVideoCheckbox');
        
        let currentText = 'FACE MASK';
        let facePosition = null;
        let faceRotation = 0;
        let autoRotation = 0;
        let smoothedFacePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let smoothedFaceRotation = 0;
        let mouthOpenAmount = 0;
        let smoothedMouthOpenAmount = 0;
        let textColor = '#ffffff';
        let lastBlinkTime = 0;
        let eyeAspectRatio = 0.3;
        
        let webcamVisible = true;
        let handAngularVelocity = 0;
        let smoothedHandAngularVelocity = 0;
        let lastHandAngle = null;
        let lastHandTime = null;
        let handPosition = null;
        
        // Tears tracking
        let sadFaceStartTime = null;
        let tearsTriggered = false;
        let activeTears = [];
        let lastTearTime = 0;
        
        // Smoothed positions for face letters
        let smoothedLeftEyePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let smoothedRightEyePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let smoothedMouthPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        const FACE_LETTER_SMOOTHING = 0.25; // Higher = more responsive, lower = smoother
        
        const ROTATION_SPEED = 0.3;
        const SMOOTHING_FACTOR = 0.15;
        const MOUTH_SMOOTHING_FACTOR = 0.25;
        const EXTRUSION_LAYERS = 30;
        const EXTRUSION_DEPTH = 40;
        const BLINK_THRESHOLD = 0.2;
        const FRICTION = 0.95;
        const HAND_ROTATION_SENSITIVITY = 0.3;
        const HAND_SMOOTHING_FACTOR = 0.2;
        
        textInput.addEventListener('input', (e) => {
            currentText = (e.target.value || 'FACE MASK').toUpperCase();
            e.target.value = currentText;
            update3DText();
        });
        
        hideVideoCheckbox.addEventListener('change', (e) => {
            webcamVisible = !e.target.checked;
            video.style.opacity = webcamVisible ? '1' : '0';
            canvas.style.opacity = webcamVisible ? '1' : '0';
        });
        
        update3DText();
        
        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        // Handle face results
        faceMesh.onResults((results) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            autoRotation += ROTATION_SPEED;
            
            smoothedHandAngularVelocity += (handAngularVelocity - smoothedHandAngularVelocity) * HAND_SMOOTHING_FACTOR;
            
            if (smoothedHandAngularVelocity !== 0) {
                autoRotation += smoothedHandAngularVelocity;
            }
            
            handAngularVelocity *= FRICTION;
            smoothedHandAngularVelocity *= FRICTION;
            if (Math.abs(handAngularVelocity) < 0.1) {
                handAngularVelocity = 0;
            }
            if (Math.abs(smoothedHandAngularVelocity) < 0.1) {
                smoothedHandAngularVelocity = 0;
            }
            
            if (autoRotation >= 360) autoRotation -= 360;
            if (autoRotation < 0) autoRotation += 360;
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                const noseTip = landmarks[4];
                const canvasX = (1 - noseTip.x) * canvas.width;
                const canvasY = noseTip.y * canvas.height;
                
                const canvasRect = canvas.getBoundingClientRect();
                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;
                const scale = Math.min(scaleX, scaleY);
                
                const faceCenterX = canvasRect.left + (canvasRect.width / 2) + ((canvasX - canvas.width / 2) * scale);
                const faceCenterY = canvasRect.top + (canvasRect.height / 2) + ((canvasY - canvas.height / 2) * scale);
                
                const leftFace = landmarks[234];
                const rightFace = landmarks[454];
                const dx = rightFace.x - leftFace.x;
                const dy = rightFace.y - leftFace.y;
                
                faceRotation = Math.atan2(dy, dx) * (180 / Math.PI);
                faceRotation = Math.max(-45, Math.min(45, faceRotation));
                
                facePosition = { x: faceCenterX, y: faceCenterY };
                
                smoothedFacePosition.x += (facePosition.x - smoothedFacePosition.x) * SMOOTHING_FACTOR;
                smoothedFacePosition.y += (facePosition.y - smoothedFacePosition.y) * SMOOTHING_FACTOR;
                smoothedFaceRotation += (faceRotation - smoothedFaceRotation) * SMOOTHING_FACTOR;
                
                mouthOpenAmount = detectMouthOpen(landmarks);
                smoothedMouthOpenAmount += (mouthOpenAmount - smoothedMouthOpenAmount) * MOUTH_SMOOTHING_FACTOR;
                
                const currentEAR = detectBlink(landmarks);
                
                if (currentEAR < BLINK_THRESHOLD && eyeAspectRatio >= BLINK_THRESHOLD) {
                    textColor = getRandomColor();
                    lastBlinkTime = Date.now();
                }
                eyeAspectRatio = currentEAR;
                
                update3DText();
            } else {
                facePosition = null;
                faceRotation = 0;
                mouthOpenAmount = 0;
                smoothedFaceRotation += (0 - smoothedFaceRotation) * SMOOTHING_FACTOR;
                smoothedMouthOpenAmount += (0 - smoothedMouthOpenAmount) * MOUTH_SMOOTHING_FACTOR;
                text3dContainer.style.display = 'none';
            }
        });
        
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const indexFinger = landmarks[8];
                
                const canvasRect = canvas.getBoundingClientRect();
                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;
                const scale = Math.min(scaleX, scaleY);
                
                const wristX = canvasRect.left + (canvasRect.width / 2) + (((1 - wrist.x) * canvas.width - canvas.width / 2) * scale);
                const wristY = canvasRect.top + (canvasRect.height / 2) + ((wrist.y * canvas.height - canvas.height / 2) * scale);
                const indexX = canvasRect.left + (canvasRect.width / 2) + (((1 - indexFinger.x) * canvas.width - canvas.width / 2) * scale);
                const indexY = canvasRect.top + (canvasRect.height / 2) + ((indexFinger.y * canvas.height - canvas.height / 2) * scale);
                
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                const wristAngle = Math.atan2(wristY - centerY, wristX - centerX);
                const indexAngle = Math.atan2(indexY - centerY, indexX - centerX);
                const handAngle = (wristAngle + indexAngle) / 2;
                
                const currentTime = Date.now();
                
                if (lastHandAngle !== null && lastHandTime !== null) {
                    let angleDiff = handAngle - lastHandAngle;
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    const timeDiff = (currentTime - lastHandTime) / 1000;
                    if (timeDiff > 0) {
                        const angularVelocity = (angleDiff / timeDiff) * (180 / Math.PI) * HAND_ROTATION_SENSITIVITY;
                        handAngularVelocity = angularVelocity;
                    }
                }
                
                lastHandAngle = handAngle;
                lastHandTime = currentTime;
                handPosition = { x: wristX, y: wristY };
            } else {
                lastHandAngle = null;
                lastHandTime = null;
                handPosition = null;
            }
        });
        
        const camera = new Camera(video, {
            onFrame: async () => {
                await faceMesh.send({image: video});
                await hands.send({image: video});
            },
            width: 1280,
            height: 720
        });
        
        function resizeCanvas() {
            if (video.videoWidth && video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const container = canvas.parentElement;
                const containerRect = container.getBoundingClientRect();
                const videoAspect = video.videoWidth / video.videoHeight;
                const containerAspect = containerRect.width / containerRect.height;
                
                if (containerAspect > videoAspect) {
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
            } else {
                    canvas.style.width = 'auto';
                    canvas.style.height = '100%';
                }
            }
        }
        
        video.addEventListener('loadedmetadata', resizeCanvas);
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (facePosition) {
                update3DText();
            }
        });
        
        camera.start();
        
        function detectMouthOpen(landmarks) {
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            const mouthWidth = Math.sqrt(
                Math.pow((mouthRight.x - mouthLeft.x) * canvas.width, 2) +
                Math.pow((mouthRight.y - mouthLeft.y) * canvas.height, 2)
            );
            const mouthHeight = Math.sqrt(
                Math.pow((lowerLip.x - upperLip.x) * canvas.width, 2) +
                Math.pow((lowerLip.y - upperLip.y) * canvas.height, 2)
            );
            
            return Math.min(mouthHeight / mouthWidth, 0.15) * 10;
        }
        
        function detectBlink(landmarks) {
            const leftEyeTop = landmarks[159];
            const leftEyeBottom = landmarks[145];
            const leftEyeLeft = landmarks[33];
            const leftEyeRight = landmarks[133];
            
            const rightEyeTop = landmarks[386];
            const rightEyeBottom = landmarks[374];
            const rightEyeLeft = landmarks[362];
            const rightEyeRight = landmarks[263];
            
            const leftEyeHeight = Math.abs(leftEyeTop.y - leftEyeBottom.y);
            const leftEyeWidth = Math.abs(leftEyeRight.x - leftEyeLeft.x);
            const leftEAR = leftEyeHeight / leftEyeWidth;
            
            const rightEyeHeight = Math.abs(rightEyeTop.y - rightEyeBottom.y);
            const rightEyeWidth = Math.abs(rightEyeRight.x - rightEyeLeft.x);
            const rightEAR = rightEyeHeight / rightEyeWidth;
            
            const avgEAR = (leftEAR + rightEAR) / 2;
            return avgEAR;
        }
        
        function getIndividualEyeAspectRatios(landmarks) {
            const leftEyeTop = landmarks[159];
            const leftEyeBottom = landmarks[145];
            const leftEyeLeft = landmarks[33];
            const leftEyeRight = landmarks[133];
            
            const rightEyeTop = landmarks[386];
            const rightEyeBottom = landmarks[374];
            const rightEyeLeft = landmarks[362];
            const rightEyeRight = landmarks[263];
            
            const leftEyeHeight = Math.abs(leftEyeTop.y - leftEyeBottom.y);
            const leftEyeWidth = Math.abs(leftEyeRight.x - leftEyeLeft.x);
            const leftEAR = leftEyeHeight / leftEyeWidth;
            
            const rightEyeHeight = Math.abs(rightEyeTop.y - rightEyeBottom.y);
            const rightEyeWidth = Math.abs(rightEyeRight.x - rightEyeLeft.x);
            const rightEAR = rightEyeHeight / rightEyeWidth;
            
            return { left: leftEAR, right: rightEAR };
        }
        
        function getFaceDistance(landmarks) {
            // Calculate face width to determine distance (wider = closer)
            const leftFace = landmarks[234];
            const rightFace = landmarks[454];
            const faceWidth = Math.abs(rightFace.x - leftFace.x);
            return faceWidth;
        }
        
        function analyzeMouthPixelColor(landmarks) {
            // Analyze pixel colors inside mouth to detect tongue vs open mouth
            // Dark/black = mouth cavity (shocked/open mouth O)
            // Lighter/flesh tone = tongue visible (P)
            
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            // Calculate center of mouth region in canvas coordinates
            const centerX = ((mouthLeft.x + mouthRight.x) / 2) * canvas.width;
            const centerY = ((upperLip.y + lowerLip.y) / 2) * canvas.height;
            
            // Sample larger area for more reliable detection
            const sampleSize = 20;
            
            try {
                // Get pixel data from video canvas at mouth region
                const imageData = ctx.getImageData(
                    Math.floor(centerX - sampleSize / 2),
                    Math.floor(centerY - sampleSize / 2),
                    sampleSize,
                    sampleSize
                );
                
                let totalBrightness = 0;
                let totalSaturation = 0;
                let pixelCount = 0;
                
                // Calculate average brightness and saturation
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    
                    // Calculate brightness (perceived luminance)
                    const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                    totalBrightness += brightness;
                    
                    // Calculate saturation (colorfulness)
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const saturation = max === 0 ? 0 : (max - min) / max * 255;
                    totalSaturation += saturation;
                    
                    pixelCount++;
                }
                
                const avgBrightness = totalBrightness / pixelCount;
                const avgSaturation = totalSaturation / pixelCount;
                
                // Return object with both metrics
                return { brightness: avgBrightness, saturation: avgSaturation };
            } catch (e) {
                // If pixel sampling fails, return neutral value
                return { brightness: 100, saturation: 50 };
            }
        }
        
        function detectTongueOut(landmarks) {
            // Enhanced tongue detection using pixel color analysis
            // Tongue = lighter flesh tones with some color saturation
            
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthWidth = Math.abs(mouthRight.x - mouthLeft.x);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // First check: mouth must be moderately open
            const isMouthOpen = mouthOpenRatio > 0.25 && mouthOpenRatio < 0.7;
            
            if (!isMouthOpen) {
                return false;
            }
            
            // Analyze pixel color in mouth region
            const mouthColor = analyzeMouthPixelColor(landmarks);
            
            // Tongue detection refined:
            // Tongue has flesh tones: medium-high brightness (80-180) + some saturation
            // Dark cavity: very low brightness (< 60) + low saturation
            const hasTongueBrightness = mouthColor.brightness > 70 && mouthColor.brightness < 200;
            const hasFlesHTone = mouthColor.saturation > 20; // Flesh has color, cavity is dark/desaturated
            
            return isMouthOpen && hasTongueBrightness && hasFlesHTone;
        }
        
        function detectMouthOpen(landmarks) {
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthWidth = Math.abs(mouthRight.x - mouthLeft.x);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // Mouth is fully open if ratio is very high (shocked/surprised face)
            // Also check for dark cavity (no tongue visible)
            const mouthBrightness = analyzeMouthPixelColor(landmarks);
            
            // Very wide open + dark inside = shocked expression (O)
            return mouthOpenRatio > 0.5 && mouthBrightness < 50;
        }
        
        function detectSmileOpen(landmarks) {
            // Detect smile with lips open (not fully open mouth)
            const mouthLeftCorner = landmarks[61];
            const mouthRightCorner = landmarks[291];
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            
            // Average Y position of mouth corners
            const cornersY = (mouthLeftCorner.y + mouthRightCorner.y) / 2;
            const upperLipY = upperLip.y;
            
            // When smiling, corners are raised relative to upper lip
            const smileIndicator = upperLipY - cornersY;
            
            // Check mouth width increases when smiling
            const mouthWidth = Math.abs(mouthRightCorner.x - mouthLeftCorner.x);
            
            // Check mouth height (open but not fully open)
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // Smile with lips open: corners raised, mouth wide, and moderately open (but not fully)
            return smileIndicator > 0.01 && mouthWidth > 0.08 && mouthOpenRatio > 0.1 && mouthOpenRatio < 0.4;
        }
        
        function detectSmileClosed(landmarks) {
            // Detect smile with lips closed
            const mouthLeftCorner = landmarks[61];
            const mouthRightCorner = landmarks[291];
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            
            // Average Y position of mouth corners
            const cornersY = (mouthLeftCorner.y + mouthRightCorner.y) / 2;
            const upperLipY = upperLip.y;
            
            // When smiling, corners are raised relative to upper lip
            const smileIndicator = upperLipY - cornersY;
            
            // Check mouth width increases when smiling
            const mouthWidth = Math.abs(mouthRightCorner.x - mouthLeftCorner.x);
            
            // Check mouth is closed
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // Smile with lips closed: corners raised, mouth wide, but closed
            return smileIndicator > 0.008 && mouthWidth > 0.075 && mouthOpenRatio < 0.1;
        }
        
        function detectFrown(landmarks) {
            // Detect frown by checking if mouth corners are lowered
            const mouthLeftCorner = landmarks[61];
            const mouthRightCorner = landmarks[291];
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            
            // Average Y position of mouth corners
            const cornersY = (mouthLeftCorner.y + mouthRightCorner.y) / 2;
            const lowerLipY = lowerLip.y;
            
            // When frowning, corners are lower (higher Y value) relative to lower lip
            const frownIndicator = cornersY - lowerLipY;
            
            // Frown detected if corners are lowered
            return frownIndicator > 0.008;
        }
        
        function detectPursedLips(landmarks) {
            // Detect pursed lips - lips pressed tightly together (different from kissing)
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthWidth = Math.abs(mouthRight.x - mouthLeft.x);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // Pursed lips: mouth is very narrow/closed and width is reduced, but mouth is tight/flat
            return mouthOpenRatio < 0.08 && mouthWidth < 0.065 && mouthWidth > 0.04;
        }
        
        function detectKissingFace(landmarks) {
            // Detect kissing face - lips puckered forward (corners close together)
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const mouthLeft = landmarks[61];
            const mouthRight = landmarks[291];
            
            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
            const mouthWidth = Math.abs(mouthRight.x - mouthLeft.x);
            const mouthOpenRatio = mouthHeight / mouthWidth;
            
            // Kissing face: mouth corners are very close together (narrow width)
            // Mouth forms a small circle/pucker shape
            return mouthWidth < 0.045 && mouthOpenRatio > 0.3 && mouthOpenRatio < 1.2;
        }
        
        function checkAndTriggerTears(landmarks, eyeX, eyeY, color, fontSize) {
            const isSad = detectFrown(landmarks);
            const currentTime = Date.now();
            
            if (isSad) {
                if (sadFaceStartTime === null) {
                    sadFaceStartTime = currentTime;
                    tearsTriggered = false;
                }
                
                const sadDuration = (currentTime - sadFaceStartTime) / 1000;
                
                if (sadDuration >= 2 && !tearsTriggered) {
                    tearsTriggered = true;
                    createTears(eyeX, eyeY, color, fontSize);
                }
            } else {
                sadFaceStartTime = null;
                tearsTriggered = false;
            }
        }
        
        function createTears(startX, startY, color, fontSize) {
            const container = document.querySelector('.container');
            
            for (let i = 0; i < 3; i++) {
                const tear = document.createElement('div');
                tear.className = 'tear';
                tear.textContent = ',';
                tear.style.position = 'absolute';
                tear.style.left = startX + 'px';
                tear.style.top = startY + 'px';
                tear.style.color = color;
                tear.style.fontSize = fontSize + 'px';
                tear.style.fontFamily = "'Penray', Arial, sans-serif";
                tear.style.pointerEvents = 'none';
                tear.style.zIndex = '7';
                tear.style.transform = 'translate(-50%, -50%)';
                tear.style.transition = 'top 2s linear, opacity 0.1s linear';
                
                container.appendChild(tear);
                
                const tearData = {
                    element: tear,
                    startTime: Date.now() + (i * 300), // Stagger by 300ms
                    startY: startY
                };
                
                activeTears.push(tearData);
                
                // Start falling after delay
                setTimeout(() => {
                    tear.style.top = (startY + 150) + 'px'; // Fall 150px
                }, i * 300);
                
                // Remove after 2 seconds of falling
                setTimeout(() => {
                    tear.style.opacity = '0';
                    setTimeout(() => {
                        if (tear.parentNode) {
                            tear.parentNode.removeChild(tear);
                        }
                        activeTears = activeTears.filter(t => t.element !== tear);
                    }, 100);
                }, (i * 300) + 2000);
            }
        }
        
        function getRandomColor() {
            const colors = [
            '#FBC6EF', '#2D493F', '#F2A3BB', '#122924', '#BD4349', '#FF74DF'];
            
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function drawFaceLandmarks(landmarks) {
            ctx.strokeStyle = '#ff69b4';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#ff69b4';
            
            for (let i = 0; i < landmarks.length; i++) {
                const x = (1 - landmarks[i].x) * canvas.width;
                const y = landmarks[i].y * canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            const outlinePoints = [
                10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
                397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
                172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
            ];
            
            ctx.beginPath();
            for (let i = 0; i < outlinePoints.length; i++) {
                const point = landmarks[outlinePoints[i]];
                const x = (1 - point.x) * canvas.width;
                const y = point.y * canvas.height;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }
        
        function update3DText() {
            text3dContainer.innerHTML = '';
            
            const displayText = (currentText || 'FACE MASK').toUpperCase();
            if (!displayText) {
                text3dContainer.style.display = 'none';
                return;
            }
            
            text3dContainer.style.display = 'block';
            
            const faceCenterX = facePosition ? smoothedFacePosition.x : window.innerWidth / 2;
            const faceCenterY = facePosition ? smoothedFacePosition.y : window.innerHeight / 2;
            const characters = displayText.split('');
            const viewportWidth = window.innerWidth;
            const radius = Math.max(viewportWidth * 0.2, 200);
            
            const totalAngle = 2 * Math.PI - (2 * Math.PI / (characters.length + 1));
            const angleStep = characters.length > 0 ? totalAngle / characters.length : 0;
            const maxRotation = smoothedMouthOpenAmount * 45;
            
            characters.forEach((char, charIndex) => {
                const baseAngle = (charIndex * angleStep) - (Math.PI / 2) - (Math.PI / (characters.length + 1));
                const angle = baseAngle + (smoothedFaceRotation * Math.PI / 180) + (autoRotation * Math.PI / 180);
                
                const charX = faceCenterX + Math.cos(angle) * radius;
                const charY = faceCenterY + Math.sin(angle) * radius;
                
                const charRotationZ = (angle * 180 / Math.PI) + 90;
                
                const baseYRotation = Math.sin(angle) * 90;
                const yRotation = baseYRotation + (smoothedFaceRotation * 0.5) + maxRotation;
                
                for (let layer = 0; layer < EXTRUSION_LAYERS; layer++) {
                    const layerElement = document.createElement('div');
                    layerElement.className = 'text-3d-layer';
                    layerElement.textContent = char;
                    layerElement.style.color = textColor;
                    layerElement.style.left = charX + 'px';
                    layerElement.style.top = charY + 'px';
                    layerElement.style.zIndex = EXTRUSION_LAYERS - layer;
                    
                    const depthOffset = (layer / EXTRUSION_LAYERS) * EXTRUSION_DEPTH;
                    layerElement.style.transform = `
                        translate(-50%, -50%)
                        translateZ(${-depthOffset}px)
                        rotateZ(${charRotationZ}deg)
                        rotateY(${yRotation}deg)
                    `;
                    
                    text3dContainer.appendChild(layerElement);
                }
            });
        }
    </script>
</body>
</html> 